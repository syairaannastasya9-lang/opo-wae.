<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tetris Kucing - Game Sederhana</title>
<style>
  body {
    background: #f0f3f5; /* warna kalem biru muda */
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
  }
  #tetris {
    border: 3px solid #a1c6e7; /* border biru kalem */
    background: #e7f0f7;
    width: 320px;
    height: 640px;
    position: relative;
    box-shadow: 0 0 15px rgba(161,198,231,0.5);
  }
  canvas {
    display: block;
    background: #e7f0f7;
  }
  /* Warna kotak dengan tema kucing kalem */
  .block {
    background: url('https://i.imgur.com/kxPZm4O.png') no-repeat center; /* gambar wajah kucing kecil */
    background-size: cover;
  }
</style>
</head>
<body>

<div id="tetris">
  <canvas id="game" width="320" height="640"></canvas>
</div>

<script>
  const canvas = document.getElementById('game');
  const context = canvas.getContext('2d');
  context.scale(20, 20); // scale untuk grid 20x20 piksel

  // Warna blok (kalem dan bertema kucing)
  const colors = [
    null,
    '#a1c6e7',  // I - Biru kalem
    '#c7d8f3',  // J - Biru muda
    '#e7f0f7',  // L - Putih kalem
    '#bcccdc',  // O - Abu abu kalem
    '#e3d9ca',  // S - Cream kalem
    '#f7f4e9',  // T - Kuning kalem
    '#c9d6d5',  // Z - Hijau kalem
  ];

  // Bentuk Tetris (blok) - menggunakan pola matriks
  const pieces = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0]
    ],
    J: [
      [2,0,0],
      [2,2,2],
      [0,0,0]
    ],
    L: [
      [0,0,3],
      [3,3,3],
      [0,0,0]
    ],
    O: [
      [4,4],
      [4,4]
    ],
    S: [
      [0,5,5],
      [5,5,0],
      [0,0,0]
    ],
    T: [
      [0,6,0],
      [6,6,6],
      [0,0,0]
    ],
    Z: [
      [7,7,0],
      [0,7,7],
      [0,0,0]
    ],
  };

  // Membuat matriks kosong
  function createMatrix(w, h) {
    const matrix = [];
    while(h--) matrix.push(new Array(w).fill(0));
    return matrix;
  }

  // Memeriksa tabrakan
  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for(let y=0; y<m.length; ++y){
      for(let x=0; x<m[y].length; ++x){
        if(m[y][x] !== 0 && (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0){
          return true;
        }
      }
    }
    return false;
  }

  // Menggabungkan blok ke arena
  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value !== 0){
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  // Menghapus baris yang penuh
  function arenaSweep() {
    let rowCount = 1;
    outer: for(let y = arena.length -1; y>=0; --y){
      for(let x=0; x<arena[y].length; ++x){
        if(arena[y][x] === 0){
          continue outer;
        }
      }
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      y++;
    }
  }

  // Membuat player baru
  function createPiece(type) {
    return pieces[type];
  }

  // Menggambar matriks
  function drawMatrix(matrix, offset){
    matrix.forEach((row,y) => {
      row.forEach((value,x) => {
        if(value !== 0){
          context.fillStyle = colors[value];
          context.fillRect(x + offset.x, y + offset.y, 1, 1);
          // Bisa ditambahkan gambar kucing di sini nanti
        }
      });
    });
  }

  function draw() {
    context.fillStyle = '#e7f0f7';
    context.fillRect(0,0, canvas.width, canvas.height);

    drawMatrix(arena, {x:0,y:0});
    drawMatrix(player.matrix, player.pos);
  }

  function playerDrop() {
    player.pos.y++;
    if(collide(arena, player)){
      player.pos.y--;
      merge(arena, player);
      playerReset();
      arenaSweep();
    }
    dropCounter = 0;
  }

  function playerMove(dir) {
    player.pos.x += dir;
    if(collide(arena, player)){
      player.pos.x -= dir;
    }
  }

  function playerReset() {
    const piecesKeys = 'TJLOSZI';
    player.matrix = createPiece(piecesKeys[(piecesKeys.length * Math.random()) | 0]);
    player.pos.y = 0;
    player.pos.x = ((arena[0].length / 2) | 0) - ((player.matrix[0].length / 2) | 0);
    if(collide(arena, player)){
      arena.forEach(row => row.fill(0));
    }
  }

  function playerRotate(dir) {
    const matrix = player.matrix;
    for(let y=0; y<matrix.length; ++y){
      for(let x=0; x<y; ++x){
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir > 0){
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }

    let offset = 1;
    while(collide(arena, player)){
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if(offset > matrix[0].length){
        playerRotate(-dir);
        player.pos.x = pos;
        return;
      }
    }
  }

  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;

  function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if(dropCounter > dropInterval){
      playerDrop();
    }

    draw();
    requestAnimationFrame(update);
  }

  const arena = createMatrix(10, 32);
  const player = {
    pos: {x:0, y:0},
    matrix: null,
  };

  playerReset();
  update();

  // Kontrol sentuh dan keyboard
  document.addEventListener('keydown', event => {
    if(event.key === 'ArrowLeft'){
      playerMove(-1);
    } else if(event.key === 'ArrowRight'){
      playerMove(1);
    } else if(event.key === 'ArrowDown'){
      playerDrop();
    } else if(event.key === 'ArrowUp'){
      playerRotate(1);
    }
  });

  // Kontrol sentuh (swipe dan tap)
  let touchStartX = null;
  let touchStartY = null;

  canvas.addEventListener('touchstart', e => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  });

  canvas.addEventListener('touchend', e => {
    if(touchStartX === null || touchStartY === null) return;

    let touchEndX = e.changedTouches[0].clientX;
    let touchEndY = e.changedTouches[0].clientY;

    let dx = touchEndX - touchStartX;
    let dy = touchEndY - touchStartY;

    if(Math.abs(dx) > Math.abs(dy)){
      // geser horizontal
      if(dx > 30){
        playerMove(1);
      } else if(dx < -30){
        playerMove(-1);
      }
    } else {
      // geser vertikal
      if(dy > 30){
        playerDrop();
      } else if(dy < -30){
        playerRotate(1);
      }
    }

    touchStartX = null;
    touchStartY = null;
  });
</script>

</body>
</html>
